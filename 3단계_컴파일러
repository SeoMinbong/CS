1. 컴파일러의 개요	
	가. 컴파일러의 필요성		
	나. 컴파일러의 인터프리터		
	다. 컴파일러의 논리적 구조		
	라. 컴파일러의 물리적 구조		
2. 형식언어와 오토마타	
	가. 형식언어의 기초		
	나. 형식문법		
	다. 문법의 표기법	
		1. 정규표현	
		2. 문법표현	
		3. BNF 표기법	
		4. EBNF 표기법	
	라. 정규언어와 유한 오토마타	
		1. 유한 오토마타	
		2. DFA 와 NFA	
		3. DFA 와 NFA의 동치 관계	
		4. DFA의 상태수 최소화	
		5. 정규표현과 유한 오토마타와의 동치관계 	
3. 어휘분석	
	가. 어휘분석기의 설계		
	나. 어휘분석기의 구현에 있어서의 고려사항		
	다. Lex와 ScanGen		
4. Contex-free 언어와 푸시다운 오토마타	
	가. Contex-free 언어와 푸시다운(push-down) 오토마타		
	나. 유도트리
(derivation tree)		
	다. 모호성(ambiguity)		
	라. 불필요한 생성규칙의 제거		
	마. ε-생성규칙의 제거		
	바. 단일 생성규칙의 제거		
	사. Left-factoring		
	아. Left-recursion의 제거		
	자. 퓨시다운 오토마타
(push-down automata)		
5. 구문분석	
	가. 구문분석의 종류		
	나. Bottom-up 구문분석	
		1. Shift-reduce 구문분석	
		2. 여러 가지의 순위문법들(precedence grammars)과 용어 정의	
		3. 연산자 순위 구문분석	
		4. 단순 순위 구문분석	
		5. * 관계행렬과 연산자 순위 구문분석	
		6. * 관계행렬과 단순 순위 구문분석	
		7. LR 구문분석	
		8. SLR 구문분석	
		9. CLR 구문분석	
		10. LALR 구문분석	
	다. Top-down 구문분석	
		1. Recursive-descent 
구문분석	
		2. Predictive 구문분석	
		3. YACC와 LALRGen	
6. 의미분석과 기호표	
	가. 의미분석의 개요		
	나. 기호표(symbol table)		
	다. 기호표의 구성		
	라. 상수정의와 의미분석		
7. 중간코드 생성	
	가. 중간코드의 종류	
		1. 후위(postfix)표현	
		2. 3-주소 코드	
	나. 문법지시적 변환
(syntax-directed translation)		
	다. 중간코드 생성	
		1. 부울식
(boolen expression)	
		2. 치환문
(assignment statement)	
8. 코드의 최적화	
	가. 코드최적화의 개념		
	나. 실행시간을 짧게 하기 위한 최적화		
	다. 소요 기억용량의 최적화		
	라. 최적화의 구현		
9. 코드의 생성	
	가. 코드생성의 개요		
	나. 산술식의 목적코드 생성		
	다. 논리식의 목적코드 생성		

 
시험 문제 예시 


		1. 다음 설명 중 맞는 것은? 
① 어휘 분석기를 만드는 기본 이론은 유한 오토마타이다. 
② 스캐너(scanner)는 파서로부터 토큰을 얻는다. 
③ 일반적으로 심볼 테이블에는 토큰 이름만 저장한다. 
④ 어휘 분석기를 만들 때 비결정적 유한 오토마타(NFA)를 이용한다. 
[정답] ① 

2. 구문분석 단계에서의 오류처리 방법과 거리가 먼 것은? 
① panic mode                       ② backtracking 
③ phrase-level recovery            ④ global correction 
[정답] ② 

3. 다음 중 하향식 구문분석 방법에 해당하는 것은? 
① 연산자 순위 구문분석            ② Predictive 구문분석 
③ LALR 구문분석                  ④ SLR 구문분석 
 [정답] ②

4. 컴파일러 구현 시 중간코드로서 일반적으로 사용되는 표현과 거리가 먼 것은? 
① three-address code            ② syntax tree 
③ postfix notation                ④ prefix notation 
[정답] ④ 

5. 언어와 번역기에 관한 설명으로 바른 것은?
①?어셈블리어(assembly language)의 한 문장은 여러 개의 기계어 문장들로 번역된다
②?기계어보다는 어셈블리어가, 어셈블리어보다는 고급언어가 배우기 쉬우나, 이식성 (portability)은 그 반대이다.
③?컴퓨터가 2진수만을 취급한다는 것과 기계어(machine language)가 0과 1만으로 작성된다는 것은 서로 무관하다.
④?크로스 컴파일러(cross-compiler)는 원시 프로그램(source program)을 컴파일러가 수행되고 있는 컴퓨터의 기계어로 번역하는 것이 아니라, 다른 컴퓨터의 기계어로 번역한다.
[정답] ④
6. 컴파일러의 번역 단계를 바르게 나열한 것은?  
① 어휘분석 ― 의미분석 ― 구문분석 ― 중간코드 생성 ― 코드 최적화 ― 목적코드 생성
② 어휘분석 ― 구문분석 ― 의미분석 ― 중간코드 생성 ― 코드 최적화 ― 목적코드 생성
③ 어휘분석 ― 의미분석 ― 구문분석 ― 코드 최적화 ― 중간코드 생성 ― 목적코드 생성
④ 어휘분석 ― 구문분석 ― 의미분석 ― 코드 최적화 ― 중간코드 생성 ― 목적코드 생성
[정답] ②

7. 다음에 정의된 결정적 유한 오토마타(DFA) M이 받아들이는 문자열은?
M = (Q, Σ, δ, q0, F)
단, Q = {q0, q1, q2, q3}
   Σ = {0, 1}
 q0 = q0
 F = {q0}
δ	  0       1
  q0	  q2      q1
  q1	  q3      q0
  q2	  q0      q3
  q3	  q1      q2

①?01	        ②?0	              ③?1	            ④?ε
[정답] ④

8. 원시 프로그램에서 의미 있는 문법적 단위(syntactic entity)를 토큰(token)이라고 부른다. 일반적인 프로그래밍 언어에 존재하는 토큰의 종류가 아닌 것은?
①?유형(type)	②?식별자(identifier)  ③?상수(constant)	④?연산자(operator)
[정답] ①

9. 생성규칙이 다음과 같을 때, 문장 001100에 대한 우파스는?
1)	S   0AS
2)	S   0
3)	A   SS
4)	A   S1A
5)	A   10

①?1 2 4 5 2	  ②?2 5 4 2 1        ③?1 4 2 5 2	     ④?2 5 2 4 1
[정답] ②
10. 푸시다운 오토마타와 가장 관계가 깊은 것은 ?
①?리스트(list)	  ②?그래프(graph)    ③?스택(stack)	④?레코드(record)
[정답] ③

1
		1. Top-down 구문분석이 backtracking 없이 결정적으로 수행되도록 고안된 방법은?
①?LR 구문분석                          ②?LALR 구문분석
③?left-recursion 구문분석               ④?recursive-descent 구문분석
[정답] ④

12. (     ) 안에 알맞은 단어를 차례로 쓰시오.
언어 번역기의 일종으로 고급언어로 작성된 프로그램을 다른 고급언어 프로그램으로 번역하는 것을 (  ㉠  )(이)라고 하며, 기계어 프로그램을 다른 기계어 프로그램으로 번역하는 것을 (  ㉡  )(이)라고 한다.
[정답] ㉠프리프로세서(preprocessor), 전처리기 
         ㉡크로스 컴파일러(cross compiler)

13. 다음과 같은 생성규칙을 갖는 문법은 context-sensitive 문법이다. 이는 | |  | | 가 성립되기 때문이다. 이러한 조건이 아니더라도 문법이 문맥에 민감한 이유를 설명하시오.
S   A
A   abC
bB   bb
CB   BC

[정답] B앞에 b가 오는 경우와 C 가 오는 경우가 다르게 해석(다른 규칙이 적용)되기 때문

14. 다음 문법에 대해 predictive 파싱표(parsing table)를 구성하는 경우, 논터미널(nonterminal) S´과 터미널(terminal) e가 만나는 칸에 들어갈 생성규칙을 쓰시오.
S → i C t S S´
S → a
 S´ → e S
 S´ → ε
 C → b
[정답] 생성규칙 S´ → e S와 S´ → ε, 이렇게 두 개가 들어간다. 따라서 이 문법은 LL(1) 문법이 아니다.
15. 1-pass 컴파일러와 2-pass 컴파일러를 비교하여 설명 하시오. 

[정답]  1-pass 컴파일러는 원시 프로그램을 한번만 읽어서 목적코드로 번역하도록 컴파일의 전 과정을 하나의 pass로 구현한 방법이다. 1-pass 컴파일러는 원시 프로그램을 한번만 읽어 가면서 번역을 하기 때문에 현재 번역되고 있는 위치에서 아직까지 번역하지 않은 부분으로의 분기(forward jumping)가 발생하는 경우 정확한 위치를 결정할 수 없기 때문에 빈칸으로 남겨 두었다가 계속되는 번역에서 정확한 정보를 얻었을 때 빈칸으로 남겨 두었던 부분을 채워 넣는 back patching을 필요로 하는 문제점이 있으나 원시 프로그램을 한번만 읽어서 직접 목적코드를 생성하므로 2-pass 컴파일러에 비해 컴파일 속도가 빠른 장점을 가진다. 2-pass 컴파일러는 입력 프로그램을 모두 두번 읽어서 목적코드를 생성하도록 구현된 컴파일러이다. 입력 프로그램을 첫번째 읽으면서 프로그램상에서 정의하고 사용된 심볼들에 대한 테이블을 먼저 생성한 후      두 번째 읽으면서 심볼 테이블의 정보를 이용하여 목적코드를 생성한다. 따라서, forward jumping과 같은 경우에도 2-pass 컴파일러에서는 back patching을 필요로 하지 않는다. 2-pass 컴파일러는 컴파일러를 기능적으로 독립된 여러 모듈로 구성할 수 있기 때문에 이식성(portability)이 높으며 중간코드를 이용한 최적화를 이용함으로써 특정 기계와 독립적인 최적화가 가능하며 프로그래머가 프로그래밍을 하는데 많은 융통성을 부여해 주는 장점이 있다. 반면, 두 번의 처리에 의해 목적코드를 생성하므로 한번의 처리에 의해 목적코드를 생성하는 1-pass 컴파일러보다 컴파일하는 속도가 느리다는 단점이 있으나, 다른 특징들로 인하여 일반적으로 2-pass 컴파일러를 많이 사용하고 있다. 
